import { DerivationsType, IndexType } from './types';
import { EnsureTypeMatchOptionsInterface } from './interfaces';
export declare function getBytes(data: Uint8Array | Array<number> | string | null | undefined, encoding?: 'hex' | 'utf8' | 'base64'): Uint8Array;
export declare function toBuffer(input: string | ArrayLike<number> | ArrayBuffer, encoding?: 'utf8' | 'hex' | 'base64'): Uint8Array;
export declare function hexToBytes(hex: string): Uint8Array;
export declare function bytesToHex(bytes: Uint8Array, prefix?: boolean): string;
export declare function bytesToString(data: Uint8Array | string | null | undefined): string;
export declare function randomBytes(len: number): Uint8Array;
export declare function bytesToInteger(bytes: Uint8Array, littleEndian?: boolean): bigint;
export declare function ensureString(data: Uint8Array | string): string;
export declare function stringToInteger(data: Uint8Array | string): bigint;
export declare function equalBytes(a: Uint8Array, b: Uint8Array): boolean;
export declare function integerToBytes(value: bigint | number, length?: number, endianness?: 'big' | 'little'): Uint8Array;
export declare function concatBytes(...chunks: Uint8Array[]): Uint8Array;
export declare function bytesToBinaryString(data: Uint8Array, zeroPadBits?: number): string;
export declare function binaryStringToInteger(data: Uint8Array | string): bigint;
export declare function integerToBinaryString(data: number | bigint, zeroPadBits?: number): string;
export declare function binaryStringToBytes(data: Uint8Array | string, zeroPadByteLen?: number): Uint8Array;
export declare function isAllEqual(...inputs: (Uint8Array | ArrayBuffer | ArrayBufferView | string | number | boolean | string[] | number[] | boolean[])[]): boolean;
export declare function generatePassphrase(length?: number, chars?: string): string;
export declare function getHmac(eccName: string): Uint8Array;
export declare function excludeKeys(nested: Record<string, any>, keys: string[]): Record<string, any>;
export declare function pathToIndexes(path: string): number[];
export declare function indexesToPath(indexes: number[]): string;
export declare function normalizeIndex(index: IndexType, hardened?: boolean): DerivationsType;
export declare function normalizeDerivation(path?: string, indexes?: number[]): [string, number[], DerivationsType[]];
export declare function indexTupleToInteger(idx: DerivationsType): number;
export declare function indexTupleToString(idx: DerivationsType): string;
export declare function indexStringToTuple(i: string): [number, boolean];
export declare function xor(a: Uint8Array, b: Uint8Array): Uint8Array;
export declare function addNoCarry(a: Uint8Array, b: Uint8Array): Uint8Array;
export declare function multiplyScalarNoCarry(data: Uint8Array, scalar: number): Uint8Array;
export declare function isBitsSet(value: number, bitNum: number): boolean;
export declare function areBitsSet(value: number, mask: number): boolean;
export declare function setBit(value: number, bitNum: number): number;
export declare function setBits(value: number, mask: number): number;
export declare function resetBit(value: number, bitNum: number): number;
export declare function resetBits(value: number, mask: number): number;
export declare function bytesReverse(data: Uint8Array): Uint8Array;
export declare function convertBits(data: number[] | Uint8Array, fromBits: number, toBits: number): number[] | null;
export declare function bytesChunkToWords(bytesChunk: Uint8Array, wordsList: string[], endianness: 'little' | 'big'): [string, string, string];
export declare function wordsToBytesChunk(w1: string, w2: string, w3: string, wordsList: string[], endianness: 'little' | 'big'): Uint8Array;
export declare function toCamelCase(input: string): string;
export declare function ensureTypeMatch(instanceOrClass: any, expectedType: any, options?: EnsureTypeMatchOptionsInterface): any;
//# sourceMappingURL=utils.d.ts.map